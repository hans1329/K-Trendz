import { useState, useEffect, useMemo } from "react";
import { useNavigate, useSearchParams, useParams } from "react-router-dom";
import V2Layout from "@/components/home/V2Layout";
import { useIsMobile } from "@/hooks/use-mobile";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

import { useToast } from "@/hooks/use-toast";
import { Mail, Link2, Loader2, Languages, Upload, X, Sparkles, ArrowLeft, ChevronDown, Check, ChevronsUpDown, CalendarIcon, Globe, Users } from "lucide-react";
import { Calendar } from "@/components/ui/calendar";
import { format } from "date-fns";
import { useAuth } from "@/hooks/useAuth";
import { supabase } from "@/integrations/supabase/client";
import { useQuery } from "@tanstack/react-query";
import { saveMentionsForPost } from "@/lib/mentions";
import RichTextEditor from "@/components/RichTextEditor";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";

const CreatePost = () => {
  const navigate = useNavigate();
  const { toast } = useToast();
  const { user, loading, isAdmin, isModerator } = useAuth();
  const [searchParams] = useSearchParams();
  const { id } = useParams();
  const isEditMode = !!id;
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");
  const [category, setCategory] = useState("");
  const [communityId, setCommunityId] = useState<string>("");
  const [wikiEntryId, setWikiEntryId] = useState<string>("");
  const [imageUrl, setImageUrl] = useState("");
  const [sourceUrl, setSourceUrl] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isExtractingUrl, setIsExtractingUrl] = useState(false);
  const [isTranslating, setIsTranslating] = useState(false);
  const [isLoadingPost, setIsLoadingPost] = useState(false);
  const [uploadedFile, setUploadedFile] = useState<File | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [isSourceUrlOpen, setIsSourceUrlOpen] = useState(false);
  const [wikiEntrySearchOpen, setWikiEntrySearchOpen] = useState(false);
  const [eventDate, setEventDate] = useState<Date | undefined>(undefined);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [tagInput, setTagInput] = useState("");
  const [postVisibility, setPostVisibility] = useState<'public' | 'fans_only'>('public');
  
  // Auto-generate dialog states
  const [showAutoGenerateDialog, setShowAutoGenerateDialog] = useState(false);
  const [autoGenerateCount, setAutoGenerateCount] = useState("3");
  const [autoGenerateKeyword, setAutoGenerateKeyword] = useState("");
  const [isGenerating, setIsGenerating] = useState(false);

  const entertainmentCategories = ["News", "Rumors", "Discussions", "Original Content", "Dramas", "OP-ED", "Videos", "Photos"];
  const cultureCategories = ["News", "Travel", "Food", "Fashion/Beauty", "Events"];
  
  // Combine all categories for the dropdown
  const allCategories = [
    { section: "Entertainment", items: entertainmentCategories },
    { section: "Culture", items: cultureCategories }
  ];

  // Fetch communities
  const { data: communities } = useQuery({
    queryKey: ["communities"],
    queryFn: async () => {
      const { data, error } = await supabase
        .from("communities")
        .select("id, name, slug")
        .order("name");

      if (error) throw error;
      return data;
    },
  });

  // Fetch followed wiki entries for the current user
  const { data: followedWikiEntries } = useQuery({
    queryKey: ["followed-wiki-entries", user?.id],
    queryFn: async () => {
      if (!user) return [];
      
      // First, get the wiki_entry_ids the user follows
      const { data: followData, error: followError } = await supabase
        .from("wiki_entry_followers")
        .select("wiki_entry_id")
        .eq("user_id", user.id);

      if (followError) {
        console.error("Error fetching followed entries:", followError);
        return [];
      }
      
      if (!followData || followData.length === 0) {
        return [];
      }
      
      const entryIds = followData.map(f => f.wiki_entry_id);
      
      // Then, get the wiki entries details
      const { data: entriesData, error: entriesError } = await supabase
        .from("wiki_entries")
        .select("id, title, schema_type")
        .in("id", entryIds)
        .order("title");

      if (entriesError) {
        console.error("Error fetching wiki entries:", entriesError);
        return [];
      }
      
      return entriesData || [];
    },
    enabled: !!user,
  });

  // Fetch available tags for search/suggestion
  const { data: searchableTags } = useQuery({
    queryKey: ["wiki-tags", tagInput],
    queryFn: async () => {
      let query = supabase
        .from("wiki_tags")
        .select("id, name, usage_count")
        .order("usage_count", { ascending: false })
        .limit(20);

      if (tagInput) {
        query = query.ilike("name", `%${tagInput}%`);
      }

      const { data, error } = await query;
      if (error) throw error;
      return data;
    },
  });

  // Fetch selected tags details (to keep them visible after selection)
  const { data: selectedTagDetails } = useQuery({
    queryKey: ["selected-tags-details", selectedTags],
    queryFn: async () => {
      if (selectedTags.length === 0) return [];
      
      const { data, error } = await supabase
        .from("wiki_tags")
        .select("id, name, usage_count")
        .in("id", selectedTags);

      if (error) throw error;
      return data || [];
    },
    enabled: selectedTags.length > 0,
  });

  // Combine searchable tags and selected tag details
  const availableTags = useMemo(() => {
    const tagMap = new Map<string, { id: string; name: string; usage_count: number }>();
    
    // Add selected tag details first
    selectedTagDetails?.forEach(tag => {
      tagMap.set(tag.id, tag);
    });
    
    // Add searchable tags
    searchableTags?.forEach(tag => {
      if (!tagMap.has(tag.id)) {
        tagMap.set(tag.id, tag);
      }
    });
    
    return Array.from(tagMap.values());
  }, [searchableTags, selectedTagDetails]);

  // Fetch wiki entry info if wiki_entry_id is present
  const { data: wikiEntry } = useQuery({
    queryKey: ["wiki-entry", wikiEntryId],
    queryFn: async () => {
      if (!wikiEntryId) return null;
      
      const { data, error } = await supabase
        .from("wiki_entries")
        .select("id, title, slug, image_url, owner_id")
        .eq("id", wikiEntryId)
        .single();

      if (error) throw error;
      return data;
    },
    enabled: !!wikiEntryId,
  });

  // Check if user is owner of the wiki entry
  const isEntryOwner = wikiEntry?.owner_id === user?.id;

  // Get wiki_entry_id or wiki_entry from URL params
  useEffect(() => {
    const wikiEntryIdParam = searchParams.get('wiki_entry_id') || searchParams.get('wiki_entry');
    if (wikiEntryIdParam) {
      setWikiEntryId(wikiEntryIdParam);
    }
  }, [searchParams]);

  // Reset form when switching between create and edit mode
  useEffect(() => {
    if (!isEditMode) {
      // Reset all form fields when entering create mode
      setTitle("");
      setContent("");
      setCategory("");
      const wikiEntryIdParam = searchParams.get('wiki_entry_id') || searchParams.get('wiki_entry');
      if (!wikiEntryIdParam) {
        setCommunityId("");
        setWikiEntryId("");
      }
      setImageUrl("");
      setSourceUrl("");
      setUploadedFile(null);
    }
  }, [isEditMode, searchParams]);

  // Load existing post if in edit mode
  useEffect(() => {
    if (isEditMode && id && user && !loading) {
      loadPost();
    }
  }, [id, isEditMode, user, loading]);

  const loadPost = async () => {
    if (!id || !user) return;
    
    setIsLoadingPost(true);
    try {
      const { data, error } = await supabase
        .from('posts')
        .select('*')
        .eq('id', id)
        .maybeSingle();

      if (error) throw error;

      if (!data) {
        toast({
          title: "Not Found",
          description: "Post not found.",
          variant: "destructive",
        });
        navigate("/");
        return;
      }

      // Check if user is the author or admin
      if (data.user_id !== user.id && !isAdmin) {
        toast({
          title: "Access Denied",
          description: "You can only edit your own posts.",
          variant: "destructive",
        });
        navigate("/");
        return;
      }

      setTitle(data.title);
      setContent(data.content);
      setCategory(data.category);
      setCommunityId(data.community_id || "");
      setImageUrl(data.image_url || "");
      setSourceUrl(data.source_url || "");
      setWikiEntryId(data.wiki_entry_id || "");
      if (data.event_date) {
        setEventDate(new Date(data.event_date));
      }
      
      // Load post visibility
      if (data.visibility === 'fans_only') {
        setPostVisibility('fans_only');
      } else {
        setPostVisibility('public');
      }

      // 이미지 공개설정은 포스트 공개설정으로 통일 (metadata 기반 옵션 제거)
      
      // Load existing tags
      const { data: postTags } = await supabase
        .from('post_tags')
        .select('tag_id')
        .eq('post_id', id);
      
      if (postTags) {
        setSelectedTags(postTags.map(t => t.tag_id));
      }
    } catch (error) {
      console.error('Error loading post:', error);
      toast({
        title: "Error",
        description: "Failed to load post.",
        variant: "destructive",
      });
      navigate("/");
    } finally {
      setIsLoadingPost(false);
    }
  };

  // Set category and community from URL parameters (only for create mode)
  useEffect(() => {
    if (!isEditMode) {
      const categoryParam = searchParams.get("category");
      const communityParam = searchParams.get("community");
      
      if (categoryParam) {
        setCategory(categoryParam);
      }
      
      if (communityParam && communities) {
        const community = communities.find(c => c.slug === communityParam);
        if (community) {
          setCommunityId(community.id);
        }
      }
    }
  }, [searchParams, isEditMode, communities]);

  // Redirect to login if not authenticated
  useEffect(() => {
    if (!loading && !user) {
      toast({
        title: "Authentication Required",
        description: "Please login to create a post.",
        variant: "destructive",
      });
      navigate("/auth");
    }
  }, [user, loading, navigate, toast]);

  const handleExtractUrl = async () => {
    if (!sourceUrl.trim()) {
      toast({
        title: "Error",
        description: "Please enter a URL",
        variant: "destructive",
      });
      return;
    }

    setIsExtractingUrl(true);
    try {
      const { data, error } = await supabase.functions.invoke('extract-url-metadata', {
        body: { url: sourceUrl }
      });

      if (error) throw error;

      if (data) {
        setTitle(data.title || title);
        setContent(data.description || content);
        setImageUrl(data.image || imageUrl);
        toast({
          title: "Success",
          description: "Article info extracted successfully",
        });
      }
    } catch (error) {
      console.error('Error extracting URL:', error);
      toast({
        title: "Error",
        description: "Failed to extract article info",
        variant: "destructive",
      });
    } finally {
      setIsExtractingUrl(false);
    }
  };

  const handleTranslateToEnglish = async () => {
    if (!title.trim() && !content.trim()) {
      toast({
        title: "Error",
        description: "Please enter title or content to translate",
        variant: "destructive",
      });
      return;
    }

    setIsTranslating(true);
    try {
      const { data, error } = await supabase.functions.invoke('translate-to-english', {
        body: { 
          title: title.trim(),
          content: content.trim() // HTML 포맷 그대로 전송
        }
      });

      if (error) throw error;

      if (data) {
        console.log('Translation received:', data);
        if (data.title) {
          setTitle(data.title);
        }
        if (data.content) {
          setContent(data.content); // HTML 포맷 그대로 적용
        }
        toast({
          title: "Success",
          description: "Translated to English successfully",
        });
      }
    } catch (error) {
      console.error('Error translating:', error);
      toast({
        title: "Error",
        description: "Failed to translate to English",
        variant: "destructive",
      });
    } finally {
      setIsTranslating(false);
    }
  };

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Validate file type
    if (!file.type.startsWith('image/')) {
      toast({
        title: "Invalid File",
        description: "Please upload an image file",
        variant: "destructive",
      });
      return;
    }

    // 이미지 용량 제한 제거 - 마스터가 고해상도 이미지 업로드 가능

    setUploadedFile(file);
    setIsUploading(true);

    try {
      if (!user) throw new Error("User not authenticated");

      const fileExt = file.name.split('.').pop();
      const fileName = `${user.id}/${Date.now()}.${fileExt}`;

      const { error: uploadError, data } = await supabase.storage
        .from('post-images')
        .upload(fileName, file);

      if (uploadError) throw uploadError;

      const { data: { publicUrl } } = supabase.storage
        .from('post-images')
        .getPublicUrl(fileName);

      setImageUrl(publicUrl);
      toast({
        title: "Success",
        description: "Image uploaded successfully",
      });
    } catch (error) {
      console.error('Error uploading image:', error);
      toast({
        title: "Upload Failed",
        description: "Failed to upload image. Please try again.",
        variant: "destructive",
      });
      setUploadedFile(null);
    } finally {
      setIsUploading(false);
    }
  };

  const handleRemoveImage = () => {
    setImageUrl("");
    setUploadedFile(null);
  };

  // 본문에서 이미지 URL 추출 (메모이제이션)
  const contentImages = useMemo(() => {
    if (!content) return [];
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(content, 'text/html');
      const images = doc.querySelectorAll('img');
      return Array.from(images)
        .map(img => img.src)
        .filter(src => src && src.startsWith('http'));
    } catch (error) {
      console.error('Error extracting images from content:', error);
      return [];
    }
  }, [content]);

  // 태그 업데이트 함수
  const updatePostTags = async (postId: string, tagIds: string[]) => {
    try {
      // 기존 태그 삭제
      await supabase
        .from('post_tags')
        .delete()
        .eq('post_id', postId);

      // 새 태그 추가
      if (tagIds.length > 0) {
        const postTags = tagIds.map(tagId => ({
          post_id: postId,
          tag_id: tagId,
        }));

        await supabase
          .from('post_tags')
          .insert(postTags);
      }
    } catch (error) {
      console.error('Error updating post tags:', error);
    }
  };

  // 태그 추가 핸들러 (엔터 키 또는 선택)
  const handleAddTag = async (tagName: string) => {
    if (!tagName.trim()) return;

    // 이미 추가된 태그인지 확인
    const existingTag = availableTags?.find(t => 
      t.name.toLowerCase() === tagName.trim().toLowerCase() && selectedTags.includes(t.id)
    );
    if (existingTag) {
      toast({
        title: "Tag Already Added",
        description: "This tag has already been added",
        variant: "destructive",
      });
      return;
    }

    // 기존 태그 검색
    const matchingTag = availableTags?.find(t => 
      t.name.toLowerCase() === tagName.trim().toLowerCase()
    );

    if (matchingTag) {
      // 기존 태그 선택
      setSelectedTags(tags => [...tags, matchingTag.id]);
      setTagInput("");
    } else {
      // 새 태그 생성 - slug 자동 생성
      try {
        const slug = tagName.trim()
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .trim();

        const { data: newTag, error } = await supabase
          .from('wiki_tags')
          .insert({ 
            name: tagName.trim(),
            slug: slug || 'tag-' + Date.now()
          })
          .select()
          .single();

        if (error) throw error;

        if (newTag) {
          setSelectedTags(tags => [...tags, newTag.id]);
          setTagInput("");
          toast({
            title: "Tag Created",
            description: "New tag has been created and added",
          });
        }
      } catch (error) {
        console.error('Error creating tag:', error);
        toast({
          title: "Error",
          description: "Failed to create tag",
          variant: "destructive",
        });
      }
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!user) {
      toast({
        title: "Authentication Required",
        description: "Please login to create a post.",
        variant: "destructive",
      });
      navigate("/auth");
      return;
    }
    
    if (!title.trim() || !content.trim()) {
      toast({
        title: "Input Error",
        description: "Please fill in title and content.",
        variant: "destructive",
      });
      return;
    }

    // Fan wiki is required
    if (!wikiEntryId) {
      toast({
        title: "Fan Wiki Required",
        description: "Please select a fan wiki to post to.",
        variant: "destructive",
      });
      return;
    }


    // 이미지 공개설정은 포스트 공개설정으로 통일 (별도 이미지 권한 없음)


    // Check daily post limit (edit 모드에서는 체크 안함)
    if (!isEditMode) {
      try {
        const { data: postStatus, error } = await supabase
          .rpc('get_daily_post_status', { user_id_param: user.id });

        if (error) throw error;

        if (postStatus) {
          const status = postStatus as { current_count: number; max_posts: number; remaining_posts: number; can_post: boolean };
          
          if (!status.can_post) {
            toast({
              title: "Daily Limit Reached",
              description: `You can only create ${status.max_posts} posts per day. Try again tomorrow!`,
              variant: "destructive",
            });
            return;
          }
        }
      } catch (error) {
        console.error('Error checking daily post limit:', error);
        // 에러 발생시 계속 진행 (포스트 생성 자체는 trigger에서 제한됨)
      }
    }

    setIsSubmitting(true);

    try {
      if (isEditMode && id) {
        // Update existing post
        const updateData: any = {
          title: title.trim(),
          content: content.trim(),
          category: communityId ? null : category,
          community_id: communityId || null,
          wiki_entry_id: wikiEntryId || null,
          image_url: imageUrl.trim() || null,
          source_url: sourceUrl.trim() || null,
          event_date: eventDate ? format(eventDate, 'yyyy-MM-dd') : null,
          visibility: postVisibility,
        };
        
        
        // 관리자는 다른 사용자의 포스트도 수정 가능
        let updateQuery = supabase
          .from('posts')
          .update(updateData)
          .eq('id', id);
        
        if (!isAdmin) {
          updateQuery = updateQuery.eq('user_id', user.id);
        }
        
        const { error } = await updateQuery;

        if (error) throw error;

        // Update tags
        await updatePostTags(id, selectedTags);

        toast({
          title: "Post Updated",
          description: "Your post has been successfully updated.",
        });
      } else {
        // 포스트 생성 전 wiki_entry의 trending_score 저장
        let previousTrendingScore = 0;
        if (wikiEntryId) {
          const { data: entryBefore } = await supabase
            .from('wiki_entries')
            .select('trending_score')
            .eq('id', wikiEntryId)
            .single();
          previousTrendingScore = entryBefore?.trending_score || 0;
        }

        // Create new post
        const insertData: any = {
          title: title.trim(),
          content: content.trim(),
          category: communityId || wikiEntryId ? null : category,
          community_id: communityId || null,
          wiki_entry_id: wikiEntryId || null,
          image_url: imageUrl.trim() || null,
          source_url: sourceUrl.trim() || null,
          event_date: eventDate ? format(eventDate, 'yyyy-MM-dd') : null,
          user_id: user.id,
          visibility: postVisibility,
        };
        
        
        const { data: newPost, error } = await supabase
          .from('posts')
          .insert(insertData)
          .select()
          .single();

        if (error) throw error;

        // 멘션 저장
        if (newPost) {
          await saveMentionsForPost(newPost.id, content, user.id);
          await updatePostTags(newPost.id, selectedTags);
        }

        // 포인트 지급 규칙 조회
        const { data: pointRule } = await supabase
          .from('point_rules')
          .select('points')
          .eq('action_type', 'create_post')
          .eq('is_active', true)
          .single();

        const earnedPoints = pointRule?.points || 10;

        // 포스트 생성 후 wiki_entry의 trending_score 조회 및 점수 상승 표시
        let scoreIncrease = 0;
        if (wikiEntryId) {
          const { data: entryAfter } = await supabase
            .from('wiki_entries')
            .select('trending_score')
            .eq('id', wikiEntryId)
            .single();
          const newTrendingScore = entryAfter?.trending_score || 0;
          scoreIncrease = newTrendingScore - previousTrendingScore;
        }

        toast({
          title: "Post Created",
          description: scoreIncrease > 0 
            ? `You earned ${earnedPoints} Stars! Entry score +${scoreIncrease}`
            : `Your post has been successfully created. You earned ${earnedPoints} Stars!`,
        });

        // Custom event 발생으로 Navbar의 일일 포스트 카운트 즉시 업데이트
        window.dispatchEvent(new Event('dailyPostsUpdated'));
        
        // wikiEntry가 있으면 해당 엔트리로, 없으면 새로 생성된 포스트로 이동
        if (wikiEntry?.slug) {
          navigate(`/k/${wikiEntry.slug}`);
        } else if (newPost) {
          navigate(`/post/${newPost.id}`);
        } else {
          navigate(-1);
        }
        return;
      }

      // Edit 모드에서 리다이렉트
      if (wikiEntry?.slug) {
        navigate(`/k/${wikiEntry.slug}`);
      } else {
        navigate(`/post/${id}`);
      }
    } catch (error) {
      console.error(`Error ${isEditMode ? 'updating' : 'creating'} post:`, error);
      toast({
        title: "Error",
        description: `Failed to ${isEditMode ? 'update' : 'create'} post. Please try again.`,
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleAutoGenerate = async () => {
    if (!user) return;

    const count = parseInt(autoGenerateCount);
    if (isNaN(count) || count < 1 || count > 10) {
      toast({
        title: "Invalid Count",
        description: "Please enter a number between 1 and 10",
        variant: "destructive",
      });
      return;
    }

    setIsGenerating(true);

    try {
      const { data, error } = await supabase.functions.invoke('generate-news-posts', {
        body: {
          count,
          category: category || 'Entertainment-News',
          keyword: autoGenerateKeyword.trim() || undefined,
          userId: user.id,
        },
      });

      if (error) throw error;

      toast({
        title: "Posts Generated",
        description: `Successfully generated ${data.generated} news posts`,
      });

      setShowAutoGenerateDialog(false);
      setAutoGenerateCount("3");
      setAutoGenerateKeyword("");
      navigate(-1);
    } catch (error) {
      console.error('Error generating posts:', error);
      toast({
        title: "Generation Failed",
        description: error instanceof Error ? error.message : "Failed to generate posts",
        variant: "destructive",
      });
    } finally {
      setIsGenerating(false);
    }
  };

  const isMobile = useIsMobile();
  
  return (
    <V2Layout pcHeaderTitle={isEditMode ? "Edit Post" : "Create Post"} showBackButton>
      <div className={`${isMobile ? 'pt-16 px-4' : ''} py-6`}>
        <div className="flex items-center justify-between mb-4">
          <Button
            variant="ghost"
            size="icon"
            onClick={() => {
              if (wikiEntry?.slug) {
                navigate(`/k/${wikiEntry.slug}`);
              } else {
                navigate(-1);
              }
            }}
            className="rounded-full"
          >
            <ArrowLeft className="w-5 h-5" />
          </Button>
        </div>
        
        <div className="px-4 sm:px-6 pt-0 pb-4 sm:pb-6">
          {isLoadingPost ? (
            <div className="flex justify-center py-12">
              <Loader2 className="w-8 h-8 animate-spin" />
            </div>
          ) : (
            <>
          <div className="mb-6">
            <h1 className="text-2xl font-bold">{isEditMode ? "Edit Post" : "Create New Post"}</h1>
            {wikiEntry && (
              <p className="text-sm text-muted-foreground mt-1 flex items-center gap-2">
                Posting to: <span className="font-semibold text-[#ff4500]">{wikiEntry.title}</span>
              </p>
            )}
          </div>
          
          <form onSubmit={handleSubmit} className="space-y-4">
            {/* Post to My Fan Wiki 영역 - 당분간 숨김 처리 (엔트리에서 직접 글쓰기로 변경됨) */}

            <div>
              <label className="block text-sm font-medium mb-2 pl-1">Title</label>
              <Input
                placeholder="Enter title"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                maxLength={140}
                className="text-sm"
              />
            </div>

            <div>
              <RichTextEditor
                value={content}
                onChange={setContent}
                placeholder="Enter content (Use @ to mention users, paste images directly)"
                minHeight="300px"
              />
              <div className="flex justify-end mt-2">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={handleTranslateToEnglish}
                  disabled={isTranslating || (!title.trim() && !content.trim())}
                  className="gap-2"
                >
                  {isTranslating ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Translating...
                    </>
                  ) : (
                    <>
                      <Languages className="w-4 h-4" />
                      Translate to English
                    </>
                  )}
                </Button>
              </div>
            </div>

            <div>
              <div className="flex items-center justify-between mb-2 gap-2">
                <label className="block text-sm font-medium pl-1">Core Image</label>
              </div>
              <div className="space-y-3">
                {!imageUrl ? (
                  <div className="flex flex-col gap-3">
                    {/* 본문 내 이미지 선택 */}
                    {contentImages.length > 0 && (
                      <div className="space-y-2">
                        <p className="text-xs font-medium text-muted-foreground">Images from content:</p>
                        <div className="grid grid-cols-3 gap-2">
                          {contentImages.map((imgSrc, index) => (
                            <button
                              key={index}
                              type="button"
                              onClick={() => setImageUrl(imgSrc)}
                              className="relative aspect-square rounded-lg overflow-hidden border-2 border-border hover:border-primary transition-colors"
                            >
                              <img
                                src={imgSrc}
                                alt={`Content image ${index + 1}`}
                                className="w-full h-full object-cover"
                                onError={(e) => {
                                  e.currentTarget.src = 'https://via.placeholder.com/150?text=Error';
                                }}
                              />
                            </button>
                          ))}
                        </div>
                      </div>
                    )}

                    {contentImages.length > 0 && (
                      <div className="relative">
                        <div className="absolute inset-0 flex items-center">
                          <span className="w-full border-t" />
                        </div>
                        <div className="relative flex justify-center text-xs uppercase">
                          <span className="bg-background px-2 text-muted-foreground">Or upload new</span>
                        </div>
                      </div>
                    )}

                    <div className="relative">
                      <input
                        type="file"
                        accept="image/*"
                        onChange={handleFileUpload}
                        className="hidden"
                        id="image-upload"
                        disabled={isUploading}
                      />
                      <label
                        htmlFor="image-upload"
                        className={`flex items-center justify-center gap-2 px-4 py-3 border-2 border-dashed rounded-lg cursor-pointer transition-colors text-sm ${
                          isUploading 
                            ? 'opacity-50 cursor-not-allowed' 
                            : 'hover:border-primary hover:bg-primary hover:text-white'
                        }`}
                      >
                        {isUploading ? (
                          <>
                            <Loader2 className="w-5 h-5 animate-spin" />
                            <span>Uploading...</span>
                          </>
                        ) : (
                          <>
                            <Upload className="w-5 h-5" />
                            <span>Upload Image</span>
                          </>
                        )}
                      </label>
                    </div>
                  </div>
                ) : (
                  <div className="relative rounded-lg overflow-hidden border border-border bg-muted/30">
                    <img 
                      src={imageUrl} 
                      alt="Preview"
                      className="w-full max-h-80 object-contain"
                      onError={(e) => {
                        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Invalid+Image';
                      }}
                    />
                    <Button
                      type="button"
                      variant="destructive"
                      size="sm"
                      onClick={handleRemoveImage}
                      className="absolute top-2 right-2"
                    >
                      <X className="w-4 h-4 mr-1" />
                      Remove
                    </Button>
                  </div>
                )}
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium mb-2 pl-1">Tags</label>
              <div className="space-y-2">
                <div className="flex flex-wrap gap-2 mb-2">
                  {selectedTags.map((tagId) => {
                    const tag = availableTags?.find(t => t.id === tagId);
                    if (!tag) return null;
                    return (
                      <div
                        key={tagId}
                        className="inline-flex items-center gap-1 px-3 py-1 bg-primary/10 text-primary rounded-full text-sm"
                      >
                        <span>{tag.name}</span>
                        <button
                          type="button"
                          onClick={() => setSelectedTags(tags => tags.filter(t => t !== tagId))}
                          className="ml-1 hover:text-destructive"
                        >
                          <X className="w-3 h-3" />
                        </button>
                      </div>
                    );
                  })}
                </div>
                <Input
                  placeholder="Search tags or type to create new..."
                  value={tagInput}
                  onChange={(e) => setTagInput(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      e.preventDefault();
                      handleAddTag(tagInput);
                    }
                  }}
                  className="text-sm"
                />
                {tagInput && availableTags && availableTags.length > 0 && (
                  <div className="border rounded-md max-h-48 overflow-y-auto">
                    {availableTags
                      .filter(tag => !selectedTags.includes(tag.id))
                      .map((tag) => (
                        <button
                          key={tag.id}
                          type="button"
                          onClick={() => handleAddTag(tag.name)}
                          className="w-full px-3 py-2 text-left text-sm"
                        >
                          {tag.name}
                        </button>
                      ))}
                  </div>
                )}
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium mb-2 pl-1">Event Date (Optional)</label>
              <Popover>
                <PopoverTrigger asChild>
                  <Button
                    variant="outline"
                    className={cn(
                      "w-full justify-start text-left font-normal",
                      !eventDate && "text-muted-foreground"
                    )}
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {eventDate ? format(eventDate, "PPP") : <span>Pick an event date</span>}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto min-w-[320px] p-0 mx-4" align="start">
                  <Calendar
                    mode="single"
                    selected={eventDate}
                    onSelect={setEventDate}
                    initialFocus
                    className={cn("pointer-events-auto")}
                  />
                </PopoverContent>
              </Popover>
              <p className="text-xs text-muted-foreground mt-1">
                If this post is about an event, select the event date. It will appear in the calendar.
              </p>
            </div>

            {/* Post Visibility - Only show when wiki_entry is selected */}
            {wikiEntryId && (
              <div>
                <label className="block text-sm font-medium mb-2 pl-1">Post Visibility</label>
                <div className="grid grid-cols-2 gap-3">
                  <button
                    type="button"
                    onClick={() => setPostVisibility('public')}
                    className={cn(
                      "flex items-center gap-3 p-4 rounded-xl border-2 transition-all",
                      postVisibility === 'public'
                        ? "border-primary bg-primary/10"
                        : "border-border hover:border-primary/50"
                    )}
                  >
                    <Globe className={cn(
                      "w-5 h-5",
                      postVisibility === 'public' ? "text-primary" : "text-muted-foreground"
                    )} />
                    <div className="text-left">
                      <p className={cn(
                        "font-medium text-sm",
                        postVisibility === 'public' ? "text-primary" : ""
                      )}>Public</p>
                      <p className="text-xs text-muted-foreground">Anyone can see</p>
                    </div>
                  </button>
                  <button
                    type="button"
                    onClick={() => setPostVisibility('fans_only')}
                    className={cn(
                      "flex items-center gap-3 p-4 rounded-xl border-2 transition-all",
                      postVisibility === 'fans_only'
                        ? "border-primary bg-primary/10"
                        : "border-border hover:border-primary/50"
                    )}
                  >
                    <Users className={cn(
                      "w-5 h-5",
                      postVisibility === 'fans_only' ? "text-primary" : "text-muted-foreground"
                    )} />
                    <div className="text-left">
                      <p className={cn(
                        "font-medium text-sm",
                        postVisibility === 'fans_only' ? "text-primary" : ""
                      )}>Fans Only</p>
                      <p className="text-xs text-muted-foreground">Only followers</p>
                    </div>
                  </button>
                </div>
                <p className="text-xs text-muted-foreground mt-2">
                  {postVisibility === 'fans_only' 
                    ? "Only fans who follow this page can see this post."
                    : "This post will be visible to everyone."
                  }
                </p>
              </div>
            )}

                <div className="flex flex-col sm:flex-row gap-3 pt-4 pb-8">
                  <Button
                    type="button"
                    variant="outline"
                    onClick={() => navigate(isEditMode ? `/post/${id}` : "/")}
                    disabled={isSubmitting}
                    className="w-full sm:flex-1 order-2 sm:order-1"
                  >
                    Cancel
                  </Button>
                  <Button type="submit" className="w-full sm:flex-1 order-1 sm:order-2" disabled={isSubmitting}>
                    {isSubmitting ? (isEditMode ? "Updating..." : "Posting...") : (isEditMode ? "Update" : "Post")}
                  </Button>
                </div>
              </form>
            </>
          )}
        </div>
      </div>
    </V2Layout>
  );
};

export default CreatePost;
